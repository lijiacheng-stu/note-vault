**缺少：**
- loop循环
- 存储函数

#### 基本语法
- 创建
```mysql
create procedure 存储过程名称([参数列表])
begin
	SQL语句 -- （自己的理解）这里面对分号好像很严格
end
```
- 调用
```mysql
call 名称([参数])
```
- 查看
	形式一：
```mysql
select * from information_schema.routines where routine_schema='XXX' 
//xxx就是要查看的数据库
```
	形式二：
```mysql
	show create procedure 存储过程名称
```
- 删除
```mysql
drop procedure [if exists] 存储过程名称
```

#### 变量
##### 系统变量 
- 定义：MySQL服务器提供，不是用户定义的，属于服务器层面
- 分类：全局变量（GLOBAL）、会话变量（SESSION）
- 注意：
	- （个人理解）每个会话有两个级别的系统变量，一个是session，一个是global，session只有当前会话会影响它的值，而global所有会话共享，一个会话更改，所有会话的都会改变。
	- 当session变量和global变量发生冲突的时候，以session变量为准。global变量更像是一种默认变量，而session变量就是实际变量
**查看** 
```mysql
show [session|global] variables; //查找所有的系统变量名
show [session|global] variables like 'XXX' //模糊查找制定的系统变量名
select @@[session|global].系统变量名 //返回制定的系统变量的值
```

**设置系统变量** 
```mysql
set [session|global] 系统变量名=值;
set @@[session|global].系统变量名=值
```
**注意：** 
- 没有指定session 和global时，默认时session 
- mysql服务重启后，所有设置的全局变量会失效

##### 用户定义变量
**特点：** 用户根据需要自定义的变量，`@变量名` 直接使用
**赋值** 
```mysql
set @变量名:=值 -- 这里的`:=`也可以用`=` 
select 字段名 into @变量名 from 表明
```
**查看** 
`select @变量名`

##### 局部变量
**特点：** 在begin……end字段中间
**声明：** 
```mysql
declare 变量名 变量类型 [default 值] -- 不可以连续声明
```
**赋值：**
```mysql
set 变量名:=值 -- 这里的`:=`也可以用`=`
select 字段名 into 变量名 from 表明
```
**查看：**
`select 变量名`

#### if判断
**语法** 
```mysql
if 条件1 then
……;
elseif 条件2 then
……;
else
……;
end if;
```
#### 参数
**类型** 
- IN 默认 作为输入 
- OUT 作为输出，也就是返回值
- INOUT 既可以作为输入，也可以作为输出
**使用案例** 
```mysql
create PROCEDURE p1(in score int,out result varchar(10))
begin
if score>=85 then set result:='优秀';
elseif score>=60 then set result:='及格';
else set result:='不及格';
end if;
end

create PROCEDURE p2(inout score int)
BEGIN
	set score:=score*0.5;
end

call p1(68,@result); -- 调用的时候，其实是得用用户自定义变量
SELECT @result


set @score:=168;  -- inout型，得先赋值
call p2(@score);
select @score;
```

#### 循环while
**语法：**
```mysql
while 条件 do
	sql语句
end while
```
**特点：**
- 满足条件，继续循环，直到不满足

#### 循环repeat
**语法：**
```mysql
repeat
	sql语句
UNTIL 条件 end repeat -- until和end repeat之间是没有分号的
```
**特点：**
- 满足条件，继续循环，直到满足
**循环的使用样例**
```mysql
drop PROCEDURE p3;

create PROCEDURE p3(in n int)
begin 
	DECLARE i int default 1;
	DECLARE sum int default 0;
	while i<=n 
	do 
		set sum:=sum+i; 
		set i:=i+1;
	end while;
	select sum;
end;

call p3(100);
 
create PROCEDURE p4(in n int)
begin
	DECLARE sum int DEFAULT 0;
	repeat 
		set sum:=sum+n;
		set n:=n-1;
		until n=0 end repeat;
	select sum;
end;

 call p4(100)
```

#### 游标
**定义：** 用来存储查询结果集的数据类型，在存储过程中可以使用游标对结果集进行循环处理
**游标声明：** （这就是一个语句，游标暂时还没有存储这个集合，可能是资源考虑吧）
```mysql 
declare 游标名称 cursor for 查询语句;
```
**打开游标：** 这个时候的游标才开始存储查询结果集合
```mysql
open 游标名称
```

**获取游标记录：** 
```mysql
fetch 游标名称 into 变量[,变量];
```
**关闭游标：**
```mysql
close 游标名称
```
**条件处理程序：** 
**语法：**
```mysql
declare handler_action handler for condition_value[,condition_value] sql语句;
```
**原理：** 当出现condition_value情况时，执行sql语句，最后退出执行当前程序，或继续执行当前程序
**填写内容：**
```mysql
handler_action:
	continue :继续执行当前程序
	exit :终止执行当前程序

condition_value:
	SQLSTATE '02000'  -- ''中写状态码
	SQLWARNING :所有01开头的SQLSTATE代码的简写
	NOT FOUND :所有02开头的SQLSTATE代码的简写
	SQLEXCEPTION ：除了01 02外
```
**使用案例：**
```mysql
drop PROCEDURE p5;

create PROCEDURE p5(in age int)
begin

	DECLARE tno int;
	DECLARE tname varchar(10);
	DECLARE tsex char;
	DECLARE tage int;
	DECLARE tdept varchar(10);
	DECLARE age_cursor cursor for select * from student where sage>=age;
	declare exit handler for not found close age_cursor;
	drop table if EXISTS old;
	create TABLE if not EXISTS old(
		sno int,
		sname varchar(10),
		ssex char,
		sage int,
		sdept varchar(5)
	);
	
	open age_cursor;
	while true do -- 当集合遍历完毕后，就退出循环了，显然这里会在这里死循环，使用条件处理程序
		fetch age_cursor into tno,tname,tsex,tage,tdept;
		insert into old VALUES (tno,tname,tsex,tage,tdept);
	end while;
end


call p5(16);
```

