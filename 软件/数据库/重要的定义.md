### 关系数据理论
- **主属性：** 只要在候选码出出现就行
- **非主属性** ：没有在任何一个候选码中出现
- **候选码：** K-F->U,属性的数量不能多也不能少，但是可能有多个
- **主码** ：候选码中的一个
- **第二范式：** 非主属性完全依赖于主码； 对于对主码完全函数依赖，对候选码部分函数依赖的不符合第二范式
- **第三范式：** 非主属性之间不存在依赖，（如果存在，那么必然是非主属性传递依赖于码的） 

### 创建存储过程 
（本质上就是创建函数）
1、创建和调用的语法
2、形参的写法
3、变量的声明
4、顺序结构、选择结构、循环结构
5、游标的使用

### 数据定义
对于表的修改：

ALTER TABLE <表名>

[ ADD[COLUMN] <新列名> <数据类型> [ 完整性约束 ] ]

[ ADD <表级完整性约束>]

[ DROP [ COLUMN ] <列名> [CASCADE| RESTRICT] ]

[ DROP CONSTRAINT<完整性约束名>[ RESTRICT | CASCADE ] ]

[ALTER COLUMN <列名><数据类型> ] ;



### 查询语句
#### 别名
	- 对查询列的别名
	- 对from表的别名：from 列名1 列别名1，列名2 列别名2
	- 对from后中select语句中的别名
#### group by,having 聚合函数
对group by 列名，已经是缩合了，不再会有重合值的列名了

CREATE [UNIQUE]
[CLUSTER] INDEX <索引名> ON <表名>(<列名>[<次序>][,<列名>[<次序>] ]…);
#### order by, 


对日期使用between and 语句

#### 认知
1、select、order by后面可以跟四类：列名，字符串常量，算数表达式，函数，这四类也都可以改别名，注意两个逗号之间的区域区别于一个列，X 列别名
2、order by 列名1 desc,列名2 asc  //可以进行多个升降排序
3、where 列名 【not】like '%刘\_宇_' escape '\'   //匹配字符串的作用
is 【not】 null
【not】 in (a,b,c)
【not】 between and



1、select,order by后面列名，字符串常量，算数表达式，函数。select name1 subname1 将name1改成subname1
2、from后面表名，对于普通表 from tbname subtbname，对于派生表
from (select name1,name2 from tbname1) as tbname2(subname1,subname2)
3、
where 列名 like 匹配字符串
in  ()
is null
between and
4、
group by 然后having 内使用聚合函数，或者在select后面

### 插入
1、插入指定个元素
- 方式一
insert into tbname(col1,col2)
value(varcol1,varcol2);
- 方式二
insert into tbname
values(varcol1,null)

2、插入子查询
insert into tbname(col1,col2)
select col3,col4
from tb3
//一一对应吧，可以省略col1和col2

### 修改
//思考一下select的关系，update和where就能产生select要查询的值
   UPDATE  <表名>

    SET  <列名>=<表达式>[，<列名>=<表达式>]…

    [WHERE <条件>]；

### 删除
       DELETE

       FROM     <表名>

       [WHERE <条件>]；
说明：
1、直接delete from tbname 就是把这个表清空
2、where是用来筛选表中元组的，自然是用where的


增删改查都有where子句，关键字 select,insert into, update,delete from


### 视图
创建视图：

CREATE  VIEW

             <视图名>  [(<列名>  [，<列名>]…)]

       AS  <子查询>

       [WITH  CHECK  OPTION]；
删除视图
drop view viewname
说明：
1、with check option 保证了对视图增删该时，对定义该视图时where子句的一致性
2、创建的本质就是把查询的结果赤条条的放在一个视图表里面
3、如果创建的时候加了列名，如果查询语句中的列名少了，那么视图就错了
4、基表和视图混起来用是可以的
5、对视图的更新和删除将会影响到导出视图的基表， 因为视图本身知识一坨数据字典而已



### 数据库完整性
**解决的问题：** 完整性定义和违约处理

#### 实体完整性
说明：
1、列级和表级别col int primary key 或者 primary key(col)
2、不能为空，构成主键的属性也不能为空，空就会拒绝插入
#### 参照完整性
说明:
1、只有表级：FOREIGN KEY (Sno) REFERENCES Student(Sno) [on delete cascade][on update no action]
2、对应的属性可以时空值，可以重复，有值的一定得保证在参照表中有此值
3、违约情况：参照表修改/插入-->拒绝  被参照表修改/删除-->拒绝mysql默认【参照表也对应修改/设置为空值】,在创建表之初可以对后者进行修正
#### 用户定义的完整性
说明：
1、属性上：
not null,
unique,
check() //数据范围，离散in，连续<>,
default 18
2、元组上：
,check(), //check单独在一个逗号句子里


#### 完整性约束命名子句




### 角色
权限 all privileges
用户 public
       GRANT <权限>[,<权限>]...

       [ON <对象类型> <对象名>]

       TO <用户>[,<用户>]...

       [WITH GRANT OPTION];

REVOKE <权限>[,<权限>]...

      [ON <对象类型> <对象名>]

      FROM <用户>[,<用户>]...;
   
	
	CREATE  ROLE  <角色名>

GRANT  <权限>［，<权限>］…

 ON <对象类型>对象名 

 TO <角色>［，<角色>］…


GRANT  <角色1>［，<角色2>］…

TO  <角色3>［，<用户1>］…

［WITH ADMIN OPTION］


REVOKE <权限>［，<权限>］…

ON <对象类型> <对象名>

FROM <角色>［，<角色>］…
