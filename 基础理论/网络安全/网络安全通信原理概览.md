
网络安全通信原理：从操作元素到应用层级的全面梳理
最基本的操作元素：
- 非对称加密
	- 公钥可以为所有人可知，私钥只能自己知道
	- 公钥加密，私钥解密
	- 私钥加密，公钥解密
- 对称加密: 加密和解密用同一个密钥
- 数字摘要

基本模块:
encryption: 确保发送的内容不会被第三者看到
- 非对称加密：
	- 用对方的公钥将发送内容加密
	- 对方用私钥解密获取内容
- 对称加密：
	- 双方用约定的session key对消息进行加密解密。

integrity: 验证保证消息未被篡改，并且确认发送方身份
- 非对称加密的情形:
	- digital signature: 对发送的内容进行数字摘要，用私钥加密，加密的结果叫做digital signature。把数字签名作为补充内容附在发送内容后。
	- 对digital signature的验证: 对收到的内容(除了数字签名字段)进行数字摘要；对digital signature用发送方的公钥对进行解密；将数字摘要与解密的结果进行对比。
- 对称加密的情形：
	- MAC(message authentication code): 对发送的内容进行数字摘要，用sessiong key加密，加密的结果叫做MAC。把MAC作为补充内容附在发送内容后。
	- 对MAC的验证：对收到的内容(除了MAC字段)进行数字摘要；对MAC用发送方的公钥对进行解密；将数字摘要与解密的结果进行对比。
	- 问题：简单上面那样认为。不过我仍然觉得只需要附上数据摘要就行。再数字签名中，修改内容后(因为有发送方公钥)，数字摘要改变，因为没有发送方的私钥，无法能到对新数字摘要加密。 但是MAC，修改内容后(说明知道session key)，那么数字摘要改变，改变后数字摘要可以加密。

基于基本模块的大模块：
authentication: 确保内容发给了正确的人/机器
- 对client进行authentication：
	- 服务器发送一个challenge
	- 客户端对challenge进行数字签名
	- 服务器对客户端的数字签名进行验证
- 对server进行authentication：
	- CA向服务器颁发SSL/TLS certifacate：
		- CA对内容(public key of server, domain, name of CA)的内容进行数字签名，得到certificate。将(public key of server, domain, name of CA, certificate)发给服务器保存。
	- 服务器向client出示SSL/TLS certifacate
	- 客户端验证SSL/TLS certifacate的CA签名进行验证

应用：
- HTTPS：
	- 对server进行authentication
	- 沟通达成以session key为密钥进行对称加密通信
	- 通信过程用session key进行MAC。
- SSH：
	- 对client进行authentication
	- 沟通达成以session key为密钥进行对称加密通信
	- 通信过程用session key进行数字签名。
	- 沟通时，允许对服务器端发送命令行。


基于基本模块的大模块(非嵌套版)：
authentication: 确保内容发给了正确的人/机器
- 对client进行authentication：
	- 服务器发送一个challenge
	- 客户端对challenge的数字摘要进行私钥加密发送给服务器
	- 服务器用客户端的公钥进行解密，将解密的结果与challenge的数字摘要进行对比。若为True，证明client身份合法。
- 对server进行authentication：
	- CA向服务器颁发SSL/TLS certifacate：
		- 对(public key of server, domain)的内容进行数字摘要，并用CA的私钥加密得到certificate。将(public key of server, domain, name of CA, certificate)发给服务器保存。
	- 服务器向client出示SSL/TLS certifacate
	- 客户端验证SSL/TLS certifacate是否为CA颁发：
		- 根据name of CA查CA公钥
		- 对(public key of server, domain, name of CA)的数字摘要与certificate用CA公钥解密的结果进行对比。





