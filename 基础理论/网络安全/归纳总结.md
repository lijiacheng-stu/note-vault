份验证：
 - 你知道什么？密码，密保问题
 - 你持有什么？私钥，硬件
 - 



ssh



1. 身份认证作用与身份认证的类别和手段
不同的人对资源的处理权限是不同的。对于销售员工，只能查看潜在客户的名单，而对于老板却可以对这个名单进行删改。现实生活种的情形，在github中，也同样适用。例如，userA创建的仓库RepoA，他具有clone, commit, delete等一切仓库的处理权限；而对于userB对RepoA却只有clone，和通过pull requese的commit建议权。
老板无法接受销售人员销毁潜在客户名单，userA也无法接受userB修改他创建的仓库。因此，当一个人对资源进行某种处理前，必要先确定他是谁，继而确定这个人是否具有这样的处置权限，再确定是否放行。
在现实生活中，我们可以通过通话时的声音，见面时的容貌，知道他是老板，她是销售。那在网络世界中，以github为例，我们怎么知道这个user是userA，那个user是userB呢？这就涉及了身份认证的问题。“如果你是……，那么你应该知道(拥有/具有特征)……”的逻辑模型来进行身份认证的，也就是
假如你是userA，那么：
- 你应该知道什么？如：
	- 密码
	- PIN
	- 安全问题
- 你应该持有什么？如：
	- 软件令牌：持有手机、邮箱、密钥
	- 硬件令牌
- 你应该是怎样的？如：
	- 长相：人脸识别
	- 声音：语音识别
	- 血型
在一次身份认证过程中，往往包含上述的一个或多个因素的认证。当user通过认证后，则被认定为userA，那么能够享受对RepoA一切权力了。

1. 与github相关的需要身份认证的一种情形
我们设想一下这样的情形，userA将github仓库repoA中的代码下载到了本地，并完成了一个功能的开发，想把此新功能同步到repoA中。
我们来分析这个情景：
- 对repoA来讲：新功能的同步，涉及对仓库内容修改(commit)操作，只有userA才有这样的权限。对于一台普通的电脑(也就是userA使用的那一台)，它就是一个路人甲，它对仓库的内容的修改不可接受。
- 对本地仓库来讲：我是一台普通电脑，但是我如果能向repoA证明，我代表的是userA，或者说操作我向repoA发起同步申请的人是userA，那么repoA没有理由不接受修改。
所以问题的关键是怎样证明本地电脑代表的是userA的问题。从`我如果是userA,我应该知道什么`的角度来讲，可以通过输入这个仓库的账号密码来实现。那么从`我如果是userA,应该持有什么`的角度来讲，应该怎样操作呢？这个问题的答案涉及ssh，它解决了包括两个层面的问题，本地电脑能持有什么，以及怎么证明本地电脑持有。

1. ssh的作用
密钥对是指一对相互关联的公钥和私钥。具有以下特点：
- 当以公钥加密的时候，只有私钥才能解密；以私钥加密的时候，只有公钥才能解密。
- 公私钥之间没有必然联系，已知公钥无法推出私钥，已知私钥也无法推出公钥。
- 公钥可以为所有人所知，私钥只能自己持有。
userA生成了一组密钥对，并且把公钥部分放在了仓库（github）上，有且仅自己持有这些公钥对应的私钥。那么如果有一个用户证明自己拥有这些私钥之一，就可以认定这个用户就是userA，因为只有userA可能有这些私钥。userA把其中一个私钥放在本地电脑上，那么再进行git push操作时，证明自己拥有私钥即可。


如果userA生成一密钥对，他向外界公布公钥，那只有userA知道这个密钥对的密钥，换句话说，只要一个user能证明他持有这个密钥对的密钥，那么我们就可以认为这个user就是userA。 




既然密钥对有这些特点，我们可不可以采取这样的形式来对本地电脑进行身份验证：

可以利用密钥对这个的特点，来进行身份验证。


密钥对和github账号是多对一的关系：一个密钥对应一个github账号，一个github账号对应多个密钥对。
github账号中持有的ssh的密钥列表，表征了


情况一: main，本地比仓库快。
![[Pasted image 20251104161246.png]]


情况二：main, 本地比仓库慢。
- 条件：
![[Pasted image 20251104161647.png]]
![[Pasted image 20251104161836.png]]
- 结果
![[Pasted image 20251104162035.png]]
- 保持同步呢？




情况三：main, 本地和仓库速度一样。
![[Pasted image 20251104161227.png]]

情况四：本地feature1 向仓库main发出请求

- feature1与main不存在冲突，feature在main的前面

- feature1与main不存在冲突，feature在main的后面

- feature1与main存在冲突，对同一行不同的修改。
![[Pasted image 20251104164228.png]]



git push origin A:B  怎么检查是否能成功？我猜测的方案，要符合以下条件：
1.B对应本地分支origin/B，B指向一个版本，orign/B指向一个版本。比较远程库B与origin/B指向的哈希值相同
2.本地分支A是origin/B的前驱。
满足两点，可以保证：fast-forward



- 相同的文件内容哈希值一定相同嘛？

![[Pasted image 20251104211958.png]]
![[Pasted image 20251104212102.png]]