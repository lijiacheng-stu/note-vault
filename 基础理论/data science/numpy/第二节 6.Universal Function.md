导入：（节与节之间的关系）
在第一节中，涉及的是对numpy array的操作，包括怎么建立array；array都有哪儿些属性；怎么通过index，slice来获取array的视图；怎么改变array的形状；怎么拆分和合并array。 解释了numpy array的一个优势，就是节省存储空间的优势。
这一节涉及是array的计算了。

原因：为什么要使用ufunc而不是使用普通的python函数。 （这一节的必要性）
The key to making it fast is to use vectorized operations, generally implemented through NumPy’s _universal functions_ (ufuncs).

python脚本的执行过程：
Python 是解释型语言，源代码在执行前会被编译成字节码。解释器逐条执行字节码，对于普通函数调用，解释器会跳转到函数体，逐条执行其中的字节码。Python 字节码是由Python解释器执行的。过程中可能包含类型检测、函数调度、函数执行、对象创建和返回结果。其中函数调度的作用是根据操作数类型选择具体的实现函数。这些函数可能是 Python 内核函数，也可能是 NumPy 等库提供的 C 语言内核函数。大多数高性能实现都是 C 语言编写的，函数执行过程，Python 解释器几乎不参与。内核代码已经是机器码了，而不是C脚本。内核代码的执行不再涉及类型检验和函数调用。

ufunc比Cpython更快的原因：
普通 Python 循环：每个元素操作都需要 Python 解释器进行类型检测和函数调用，因此执行较慢。ufunc：Python 先进行一次元素类型检查和函数调度，选择合适的 NumPy C 内核函数。循环和元素级操作在 C 层机器码中执行，直接操作连续内存中的数组元素，Python 解释器几乎不参与（不再涉及类型检测和函数调用的过程），效率极高。

误区：
- 认为numpy array用了ufunc后，就是对array的每个位置并行地进行相同地操作。

深度：
- ufunc 的本质就是把循环从 Python 字节码层“下推”到 C 内核层。Python 层只执行一次字节码调用 ufunc，循环和元素级操作在 C 内核函数中执行，Python 解释器几乎不介入，省去了每个元素的类型检测和函数调用开销。

ufunc都包含哪儿写？（内容）
意识：在进行算数运算的时候，都得想想，有没有ufunc
内容:
A. 基本的功能
-  算术运算
![[Pasted image 20250926151715.png]]

-  绝对值： `abs()`等价`np.abs()`
-  三角函数：`np.cos(theta)`
-  其他：罕见的可能在`sciPy.special`中找得到
	![[Pasted image 20250926153632.png]]

B. 先进的功能
 - out参数指定输出位置
 - Outer Products:笛卡尔积运算
 - 聚合操作：
	 - 函数：
		 - reduce
		 - accumulate

		- min, max, median
		- sum,product
		- mean, std, var
	![[Pasted image 20250926213127.png]]
```
有两种ufunc版的：
方式一：
- `np.man(L)`
方式二：
- L.max()
注意: 内置函数max(L)不是ufunc


Aggregation functions take an additional argument specifying the _axis_ along which the aggregate is computed.The `axis` keyword specifies the dimension of the array that will be _collapsed_
```
	