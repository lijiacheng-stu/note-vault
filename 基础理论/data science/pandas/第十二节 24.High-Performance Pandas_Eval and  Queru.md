为什么要引入eval/query函数：
- 省内存：在进行复合表达式的计算的时候，中间结果的记录产生额外的内存开销。eval能避免，提高了运算效率节省内存空间。
- 省时间：中间结果的存储在多级Cache中，也可以在内存中。所以小数组计算和eval没啥区别，大数组eval能避免Cache内存之间的传输时间。
- 表达式更简洁

都有哪儿些操作：
- 运算符：
	- 算数运算
	- 比较运算
	- 逐比特的逻辑运算
- Object attributes 
- indices
- function calls,
- conditional statements
- loop

pd.eval支持的操作：
- 算数运算
- 比较运算
- 逐比特的逻辑运算
- object attributes
- indice（仅仅支持整数, 支持masking expression）
```
// index非整除，出现报错
df = pd.DataFrame(rng.random((3, 2)), index=list('ABC'), columns=['col1', 'col2'])
pd.eval('df.loc['A']')

// index是整数，不报错
pd.eval('df.iloc[0]')
```

pd.eval和DataFrame.eval的区别：
- DataFrame.eval引入了namespace of columns，这样对逐列操作引用调用该方法的Dataframe对象的列的时候，可以直接用列名了
- DataFrame.eval要使用namespace of python object需要用符号`@`
```
`@`在DataFrame.eval中的作用：
	The `@` character here marks a _variable name_ rather than a _column name_, and lets you efficiently evaluate expressions involving the two “namespaces”: the namespace of columns, and the namespace of Python object
```

对两种查询的理解：
- 方式一：masking expresion
```
df[(df.A < Cmean) & (df.B < Cmean)]
```
表达式`(df.A < Cmean) & (df.B < Cmean)`得到的是Series of Booleans，然后与df的行匹配，是True保留，否则去除。

- 方式二：DataFrame.query
```
df.query('(A < @Cmean) & (B < @Cmean)')
```
遍历df的每一行，符合query expression的保留，否则去除
query方法只有对象方法，没有pd.query
