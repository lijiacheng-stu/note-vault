三元组存储，用于存储RDF的数据的数据库系统。Resource Description Framework
RDF的数据的示例：
```turtle
# 定义命名空间（类似编程中的包名，简化URI书写）
@prefix ex: <http://example.org/geo/> .  # 自定义地理信息命名空间
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .  # RDF核心命名空间
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .  # 数据类型命名空间

# 描述第一个实体：北京市（主语）
ex:Beijing
  rdf:type ex:City ;  # 类型：城市
  ex:name "北京市"@zh ;  # 属性：名称（中文）
  ex:name "Beijing"@en ;  # 属性：名称（英文）
  ex:area 16410.54^^xsd:double ;  # 属性：面积（数值，单位：平方千米）
  ex:population 2184.3万人^^xsd:string ;  # 属性：常住人口
  ex:administrativeRegion "中国华北地区"^^xsd:string ;  # 属性：行政区域
  ex:contains ex:ForbiddenCity ;  # 关系：包含（故宫）
  ex:hasLongitude 116.403874^^xsd:double ;  # 经度
  ex:hasLatitude 39.914885^^xsd:double ;  # 纬度
  ex:builtTime "1949-10-01"^^xsd:date .  # 新中国首都确立时间

# 描述第二个实体：故宫（主语）
ex:ForbiddenCity
  rdf:type ex:HistoricalSite ;  # 类型：历史遗迹
  ex:name "故宫"@zh ;
  ex:name "The Forbidden City"@en ;
  ex:area 720000^^xsd:double ;  # 面积（平方米）
  ex:builtDynasty "明朝"^^xsd:string ;  # 建造朝代
  ex:locatedIn ex:Beijing ;  # 关系：位于（北京）
  ex:hasLongitude 116.397488^^xsd:double ;
  ex:hasLatitude 39.916395^^xsd:double .
```


Property graphs：
```cypher
// 1. 创建 城市节点 + 景点节点（带自身属性）
CREATE 
  (bj:City {
    id: "C001", 
    name: "北京市", 
    area_km2: 16410.54, 
    longitude: 116.40, 
    latitude: 39.91, 
    level: "直辖市"
  }),
  (gc:ScenicSpot {
    id: "S001", 
    name: "故宫博物院", 
    area_m2: 720000, 
    built_dynasty: "明朝", 
    ticket_price: 60.0, 
    longitude: 116.40, 
    latitude: 39.92
  }),
  (gw:ScenicSpot {
    id: "S002", 
    name: "八达岭长城", 
    area_m2: 2000000, 
    built_dynasty: "明朝", 
    ticket_price: 40.0, 
    longitude: 115.98, 
    latitude: 40.34
  })

// 2. 创建 城市与景点的关系（边带属性，核心特征）
CREATE
  (bj)-[:HAS_SCENIC_SPOT {
    distance_km: 0.5,  // 故宫到北京市中心距离
    traffic: "地铁1号线可达",
    opening_year: 1925
  }]->(gc),
  (bj)-[:HAS_SCENIC_SPOT {
    distance_km: 70.0, // 长城到北京市中心距离
    traffic: "京藏高速自驾1.5小时",
    opening_year: 1953
  }]->(gw)
```


用RDF等价描述：
```turtle
# 1. 定义命名空间（简化URI）
@prefix ex: <http://example.org/geo/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

# 2. 定义类（对应属性图的节点标签：City/ScenicSpot）
ex:City a rdfs:Class .
ex:ScenicSpot a rdfs:Class .
ex:HasScenicSpotRelation a rdfs:Class .  # 新增：关系类（对应属性图的边标签）

# 3. 描述城市节点（对应属性图的bj节点）
ex:City_C001 a ex:City ;
  ex:id "C001"^^xsd:string ;
  ex:name "北京市"@zh ;
  ex:area_km2 16410.54^^xsd:double ;
  ex:longitude 116.40^^xsd:double ;
  ex:latitude 39.91^^xsd:double ;
  ex:level "直辖市"^^xsd:string .

# 4. 描述故宫节点（对应属性图的gc节点）
ex:ScenicSpot_S001 a ex:ScenicSpot ;
  ex:id "S001"^^xsd:string ;
  ex:name "故宫博物院"@zh ;
  ex:area_m2 720000^^xsd:double ;
  ex:built_dynasty "明朝"^^xsd:string ;
  ex:ticket_price 60.0^^xsd:double ;
  ex:longitude 116.40^^xsd:double ;
  ex:latitude 39.92^^xsd:double .

# 5. 描述八达岭长城节点（对应属性图的gw节点）
ex:ScenicSpot_S002 a ex:ScenicSpot ;
  ex:id "S002"^^xsd:string ;
  ex:name "八达岭长城"@zh ;
  ex:area_m2 2000000^^xsd:double ;
  ex:built_dynasty "明朝"^^xsd:string ;
  ex:ticket_price 40.0^^xsd:double ;
  ex:longitude 115.98^^xsd:double ;
  ex:latitude 40.34^^xsd:double .

# 6. 核心：描述“北京-故宫”的关系（边属性转化为关系实体的属性）
ex:Relation_BJ_GC a ex:HasScenicSpotRelation ;  # 关系本身成为独立实体
ex:Relation_BJ_GC ex:sourceNode ex:City_C001 ;   # 关系的源节点（北京）
ex:Relation_BJ_GC ex:targetNode ex:ScenicSpot_S001 ;  # 关系的目标节点（故宫）
ex:Relation_BJ_GC ex:distance_km 0.5^^xsd:double ;    # 边属性1：距离
ex:Relation_BJ_GC ex:traffic "地铁1号线可达"^^xsd:string ;  # 边属性2：交通
ex:Relation_BJ_GC ex:opening_year 1925^^xsd:int ;      # 边属性3：开放年份

# 7. 描述“北京-八达岭长城”的关系（边属性转化为关系实体的属性）
ex:Relation_BJ_GW a ex:HasScenicSpotRelation ;
ex:Relation_BJ_GW ex:sourceNode ex:City_C001 ;
ex:Relation_BJ_GW ex:targetNode ex:ScenicSpot_S002 ;
ex:Relation_BJ_GW ex:distance_km 70.0^^xsd:double ;
ex:Relation_BJ_GW ex:traffic "京藏高速自驾1.5小时"^^xsd:string ;
ex:Relation_BJ_GW ex:opening_year 1953^^xsd:int .
```




In the temporal dimension, MTT indexing and temporal table partitioning are adopted;



2.1 地理时空语义查询：
2.1.1  查询要求：查找 Mary 及其社交圈（直接好友或好友的好友）在过去一年内在纽约市且距离最近地铁站 500 米范围内访问过的餐厅。

2.1.2  数据：
- Mary的好友：f1, f2, f3
- 个人信息： Mary，f1, f2, f3
- 餐厅信息：din_1， din_2， din_n
- 地铁站信息：sub_1， sub_2， sub_n
- 消费记录信息：msg_i（人，时间，餐厅）

2.1.3 查询的手段：查询mary的消费记录，找到用餐过的餐厅，判断餐厅是否在一年内访问过；查询餐厅信息和地铁站信息，判断餐厅是否距离最近的地铁站在500m以内。再查询mary的好友，再递归查询。

2.2 （当前研究现状）问：高效存储和管理多源地理时空数据，同时支持深度语义提取和查询分析？（当前，针对上面的查询，现有的技术手段）
2.2.1 RDBMS：
- 缺点：难以高效处理关联分析。struggles to effectively express complex relationships, requiring costly operations like multi-table JOINs, which is a computationally intensive process.
	- 例如：联合个人信息与消费记录信息等多个表时，很多没有必要的信息也联合在一起，有额外开销。
- 优点：在地理空间数据存储和计算方面表现出色。possess significant advantages in spatiotemporal query performance, leveraging mature indexing mechanisms and query optimization techniques。
	- 例如：得到餐厅的位置信息后，通过对地铁站信息执行`where  dist(loc_din_n, loc_sub_i)<500` 一个表达式就可以直接知道符合距离要求的地铁站

2.2.2 GDBMS：
- GDBMS 的基本思想：节点--边--节点
	- **节点（Node）**：表示实体（人、商品、账户、设备等）
	- **边（Edge）**：表示实体之间的关系（朋友、购买、转账、依赖等）
	- **属性（Property）**：节点和边都可以携带键值属性
- 优点：擅长处理复杂语义关联。If explicit relationships are defined for each node, accessing directly associated edges or adjacent nodes of a node has a constant time complexity of O(1).
- 缺点：在拓扑分析、地理计算等地理空间分析任务中效率较低。
	- 每次单独查询地铁站节点，提取位置属性，比较是否小于500m以内。 -->时空信息被看作普通属性，分散存储在各个节点上，不符合局部性原理。
- 现有的技术：
	- 三元组存储
	- Property graphs
	- Ontology-based data access (OBDA) methods
- 三元组存储 和  Property graphs的区别

2.3 问题的提炼：
原文：The expected query results are subgraphs that simultaneously satisfy both graph constraints and spatial-temper constraints.
- 图约束：Mary →好友→  (f1, f2, f3); (Mary, f1, f2, f3)→ 访问过->餐厅；
- 空间约束：餐厅位于纽约市 + 距离最近地铁站 500 米内；
- 时间约束：过去一年内
其中，图约束是GDBMS 擅长的，时空约束是 RDBMS擅长的。

3. 创新点：we propose GraST, a geospatial-temporal semantic query optimization method that integrates property graphs and relational databases.
![[Pasted image 20251227215340.png]]


4. 具体的实现：
以存储（福州大学，1958年8月25日，包裹福州大学的一个多边形）为例：
4.1 在GDBMS侧的存储：
- 涉及的部分
- 步骤一：（福州大学，1958年8月25日，包裹福州大学的一个多边形） --> （EntityID, EntityClass(学校), 福州大学，1958年8月25日，包裹福州大学的一个多边形）
	- 在图数据库中创建一个节点geo-node，这个节点仅存储EntityID，这个geo-node唯一地代表福州大学。
	- 创建semantic label，存储EntityClass，让geo-node与EntityClass关联。这种关联，表示 福州大学属于学校类。
![[Pasted image 20251227220153.png]]
- 步骤二：创建temporal index graphs ：Multi-granularity Time Tree (MTT)
	- 一种树的数据结构，（1年，12个月） （1月，32天），递归地构建MTT
	- 让context nodes与其中的叶子结点关联。
![[Pasted image 20251227225535.png]]
- 步骤三：创建spatial index graphs
	- 前置知识：
		- MBR：minimum bounding rectangle：
		![[Pasted image 20251227222035.png]]
		- Geohash encoding：定位一个红点
			- 过程：
				- 地球分成四个部分，红点在右上角：11
				- 把左上角分成四个部分，红点在右下角：10  --> 11 10
				- 把有小脚分成四个部分，红点在左上角：01 --> 11 10 01 
				- ……
				- 30个二进制数 --> 五个二进制数字一组 --> 数值 --> 字符“wx48uy”
			- Geohash：由以上过程得到的字符，叫做Geohash
			- Geohash encoding：产生Geohash的过程
			-  Geohash grids：统一尺度下，得到的一个个网格。1200 × 609.4 m（足球场100–110 米，比足球场大得多）
			- 特点：字符越长，Geohash grids越小，字符是一个超参数，可以用户自定义。
		- ![[Pasted image 20251227221625.png]]
	- 得到福大的MBR
	- 得到与MBR有相交部分的所有Geohash grids，从而得到一组Geohash，并以此为键，得到Geohash nodes
	- 让context nodes与Geohash nodes关联
4.2 在RDBMS侧的存储：
- （福州大学，1958年8月25日，包裹福州大学的一个多边形） --> （EntityID, EntityClass(学校), 福州大学，1958年8月25日，包裹福州大学的一个多边形）
- 由上可知：下面都会由RDBMS存储
	- 福大的名字没有存储。
	- 上面没有存储包裹福州大学的一个多边形，只存储了大概的一个轮廓。
	- 时间粒度也只精确到天，无法存储更细的粒度。
- 步骤一：创建表格，插入一个元组（
	- 创建一个学校表（根据EntityClass创建表格）
	- 插入一个以EntityID主键的元组
- 步骤二：把多边形以Well-Known Text (WKT) format，存储到“geom” 列，把覆盖到的Geohashes，存储的Geohash列
- 步骤三：（仅针对光栅数据，向量数据跳过）
- 步骤四：把1958年8月25日插入过“time”列
- 底层优化：
	- 根据“geom” 列，建立B树
	- 根据时间列，对学校这个大表，按照各种粒度划分成小表。
![[Pasted image 20251227224410.png]]

4.3 RDBMS侧与GDBMS侧的存储的数据的联动机制：
- 时空实体的关联映射
	- EntityClass： 节点的label， 表名
	- EntityID：节点标识符， 主键
		- EntityClass，EntityID
	- Time: 与MTT中的节点关联的边， 时间列（时间划分表的依据）
	- Geohash：与Geohash node节点关联的边， 
- 对**地理时空实体映射引擎**的理解：
	- ![[Pasted image 20251227231332.png]]
	- ![[Pasted image 20251227233831.png]]
	- 可以实现：
		- 对一种数据库的查询结论，可以用于查询另外一个数据库，提高查询效率：
			- 向GBDMS进行图约束查询：
				- 图约束：Mary →好友→  (f1, f2, f3); (Mary, f1, f2, f3)→ 访问过->餐厅；
			- 根据上面的查询结果，向RBDMS进行时空约束查询
				- 时间约束：过去一年内
				- 空间约束：餐厅位于纽约市 + 距离最近地铁站 500 米内；
					- 在代笔过去一年内的划分子表中查询餐厅位置
					- 查询地铁站，判断地铁站是否小于500m
		- 数据同步：
			- ![[Pasted image 20251227234447.png]]
			- ![[Pasted image 20251227234302.png]]
			- 关键字：two-phrase commit
			- ![[Pasted image 20251228000347.png]]
- 什么时候用到temporal index graphs和spatial index graphs？
	- 查询中包含了时空约束信息和图约束信息。在GDBMS利用这些信息：
		- temporal index graphs的粒度有限（比如只能精确到天），但是时间约束精确到小时。尽管不能明确具体的符合条件的entityId是哪儿一个，但是可以初筛很多
		- spatial index graphs的粒度有限（只能到geohash grid），但是也能起到初筛作用
		- 将初筛结果传给client of database，再向rdbms查询具体的entityId。减少了rdbms中查询的数量。
- 如何将一个查询，转化成对gdbms和rdbms的语句的组合？查询转换引擎：
	- ![[Pasted image 20251228001850.png]]
	- 对于normal user来讲，这个系统就是一个GDBMS。因此，normal user发起一个查询请求。
	- 
	- ![[Pasted image 20251228002141.png]]
	- GDBMS中，
	

本文提出一种融合属性图与关系数据库的地理时空语义查询优化方法 **GraST**


