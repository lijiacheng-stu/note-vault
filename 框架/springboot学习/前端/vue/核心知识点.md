#### 一、setup
setup是vue2到vue3的升级点，vue2中data，methods，computed，watch分别放置在不同的位置，对于一个变化的改变，需要改动很多地方。vue3中为了解决这个问题，将这些东西全部放在了`<script lang='ts' setup> </script>` 中。
显然还有组件名没有赋值进去，下载一个插件`vite-plugin-vue-setup-extend` ,并且在文件vite.config.ts进行配置
![[Pasted image 20250219211824.png]]
这样就可以`<script lang='ts' setup name='Person'> </script>`完成名字的名字。

#### 二、响应式数据
有两种类型的响应式数据，ref和reactive。
- 适用性：
ref适用于基本数据类型和对象类型，reactive只能用于对象类型。
- 响应式的本质：
需要从vue中引入的方法， 返回值都是对象，名字分别是ref，proxy。
reactive的对象
![[Pasted image 20250221094441.png]]
ref的对象
![[Pasted image 20250221094556.png]]
原则：只要变量名所指向的proxy和ref对象的地址不发生变化， 则数据仍然是响应式的，因为template模板中的响应式数据是绑定对应地址的。所以这就产生了两种结果，reactive定义的变量，如果赋值成了其他对象，则变量不再是响应式的，而ref定义的变量的value属性赋值成了其他对象则仍然是响应式的。
- 保证响应式前提的赋值与读值
ref在script中进行对某一属性赋值时，对基本数据类型用到 `变量名.value=值`，对于对象类型用到`变量名.value.属性名=值` ，读数等同；在template中则不需要直接，对于基本数据类型的ref直接写变量名，对于对象类型的直接'变量名.对象属性'。注ref底层是使用reactive实现对象的封装的，并由value属性指向此对象。
reactive在script中对某一属性进行赋值时，用到`变量名.属性名=值` ，读数等同
- 特点
响应式数据的特点就是当数据发生变化，template中对应的位置的数据也发生变化，这强调的数据流向是script到template。

#### 三、computed计算属性
computed是一种方法，需要中vue中引入。有两种情况：
第一种computed中承接一个getter函数，返回一个只读的ref对象，返回值会对一个变量进行赋值,并形成缓存。缓存的作用是对fullname有读且getter函数中依赖的ref变量未发生变化，则不再调用函数。若依赖ref变量发生变化，则重新调用函数。
```
import{computed} from 'vue'
let fullname = computed(()=>{
	return 'xiaozhang'
})
```
第二种computed中承接get和set两个函数
这样返回的是可读可写的ref对象。对变量读的时候，读的时候调用get函数,基本上可以参照第一种情况的内涵来理解。对变量写的时候，写的值调用set函数，写的内容'Xiao-hong'赋值给val，然后执行set中的函数体。要充分利用依赖的ref变量变化时，会执行get函数对变量重新赋值的特性，使用set函数
```
import{computed} from 'vue'
let fullname = computed({
	get(){
	},
	set(val){
	}
})

//对fullname写
fullname.value = 'Xiao-hong'
```


#### 四、监视watch
```
watch(监视源,callback,option?)
```
##### 1.监视源的类型
- ref定义的数据
- reactive定义的数据
- getter函数 （也就是有返回值的函数）
- 包含上述内容的数组
##### 2.callback格式
```
(newValue,oldValue)=>{
	函数体
}
```
- newValue，oldValue分别指向变化前后对应地址值，然后再读取内容。
- 在实际开发中，更关注于newValue，从而形参命名为Value
##### 3.option
- {deep：true | false}
##### 4.对ref定义的数据的监视
value属性的值是基本数据时，该基本数据会被监视，当内容发生变化调用callback函数，并新值和旧值都会被赋值给callback的两个形参。赋值后由于地址值改变，所以newValue和oldValue不同。
value属性的值是对象数据时，默认地址值被监视，也就是说只要地址值不变，就算对对象的属性改变也不会引起callback函数的调用。通过对第三个形参赋值，实现对地址指向对象的内容进行监视，也就是深度监视`{deep:true}`，这种情况下，改变形参的属性，由于地址值未改变，所以newValue和oldValue会相同。
##### 5.对reactive定义的数据的监视
reactive只可能定义对象类型，就是深度监视，也就是对象的一根毛发生变化，也会引起callback的调用，且无法关闭。

##### 6.对getter函数的监视
getter函数是有返回值的函数，在监视中，只能是与响应式数据有关的返回值，用于监视响应式数据的指定属性。当return的内容发生变化时，调用callback函数。
对于return返回的是地址值，所以若地址值不变，则认为return内容不变。这就产生了这样的效果，若是基本数据类型，则进行赋值，必然引起地址变化，则调用callback；对于对象类型，则通过属性赋值，则地址值不变，则不调用callback。要监视对象的具体内容，则打开深度监视。
callback函数中的newValue和oldValue分别指向前后两次的return结果。

##### 7.其他
```
watchEffect(callback)
```
与watch的区别是不需要写监视源，callback中的响应式数据作为监视源，监视源发生变化，自动执行callback

#### 五、生命周期
#### 六、路由
##### 1.使用步骤
- 1.安装依赖vue-router
在终端`npm i vue-router`
检查是否安装成功的方法：
![[Pasted image 20250223213209.png]]
- 2. src下创建文件下名为views或pages的文件夹，用于存放路由组件，编辑组件
![[Pasted image 20250223213454.png]]
- 3.创建文件夹router，并在文件夹下创建文件index.ts用于配置路由
这个过程就是创建一个router变量，变量内包含工作模式，以及path到component的映射列表。path就是网页，components就是路由组件。记得暴露该变量。
![[Pasted image 20250223213950.png]]
- 4.在src下的main.ts中进行编辑，使得创建的app使用上面编辑的路由变量，下面的router就是上一步的router变量
![[Pasted image 20250223214055.png]]
- 5.需要展示此组件。在App.vue的ts中，从vue-router中引入组件RouterView，此组件所在位置将是访问路径时，路由组件展示的位置
![[Pasted image 20250223214422.png]]
- 6.需要点击某位置，跳转到对应的路径。使用RouterLink组件。属性to，表示点击该组件后，跳转的路径；属性active-class表示被激活时的类名，用于样式修改
##### 2.知识点

##### 细节
1.路由组件放在文件夹views或pages下
2.to的写法




