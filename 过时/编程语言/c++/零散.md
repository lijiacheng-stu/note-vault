- 在c++中的关键字class和关键字基本上是struct是等价的，但是有一点点区别。为了兼容C语言，在C语言中struct没有声明访问权限这个步骤，可以由所有的函数或者变量访问，所以struct中的成员默认都是public的，而class默认都是private私有的。
- 进入{}brace初，就对brace中的变量所需的内存给分配好，不过当程序运行到响应位置的时候才对变量进行初始化。这引出了动态内存分配的需求
- `#include ""` 与`include <>` 编译只需要编译源程序，对于源程序中的include进来的头文件，编译器自己会去查找。对于尖括号，编译器会在系统的标准目录中查找指定的头文件；对于双引号，在当前项目的源码所在位置及其子目录下寻找该头文件
- 本地变量放在堆栈，new出来的东西放在堆里面，全局变量放在一个全局数据区里面。`"hello world"`这个字符串代码段里面，代码段是不可写的。
- `char* s = "hello world"` 和`char s[] = "hello world"`是有区别的。前者是直接给地址，后者是分配内存空间，将数值赋值到内存空间中。
- java和c++相比，c++的复杂度是高多了，体现之一就是内存模型。在java中，对象只能存在堆中，访问对象只能通过指针。 在c++中，对象能够存在堆栈中(本地变量为对象的)，全局数据区中（全局变量为对象的），堆中（new出来的）；访问对象的方式有三种，变量名，pointer，reference，组合起来有9种。
- 通过指针，在client class中实现对private成员变量的访问和赋值：
```
class C{
private:
	int i;
	const int j;
public:
	C():i(20),j(30){}
}
int main(){
	C c;
	int* p =(int*) &c;
	cout << *p << endl; //实现了读
	*p = 40;
	cout << *p << endl; //实现了写
	p++;
	*p = 60;
	cout << *p << endl; //实现了const的写
}
```
- c++和java在处理继承具有相同函数名的成员函数时的区别，涉及override，overload和继承：
形式、语境：
父类中函数名相同，参数列表不同的函数若干（返回值可同可不同）
子类中有一个与父类中函数名，参数列表，返回值均相同的函数。
被一个client class访问。
对于Java:
子类中的该函数override父类中的该函数，继承其他同名函数。子类中无法调用父类中的该函数了。所以在client class中访问该函数时，访问override之后的函数，其同名函数也能被看到。
对于c++：
子类中的该函数不override父类中的该函数，而是并立添加函数。在子类的访问中，对于父类中所有同名函数的访问都得加上`base::` （base表示基类的类名）；在client class的访问中，无法访问到父类的函数，被屏蔽。
怎样实现类似于java中的功能呢？

多态的实现--upcast下的动态绑定:
```
void f(Animal *p){
	p->eat();
}
```
Animal有子类Dog和Cat，都有`void eat()`，如何实现给形参传递Dog时，调用Dog中定义的eat函数，Cat时，调用Cat的eat()?
若无任何操作的情况下，无论是传Dog还是Cat的对象，都只调用Animal的eat()。若在Animal中函数定义时，添加关键字`virtual`，且通过指针实现向上造型upcast，通过指针调用相应的函数，则可实现以上目的。
实现的原理，成员函数有virtual修饰的话，该类的对象的内存开头都有一个隐藏的VPtr指针指向vtable。vtable是被virtual修饰的成员函数的地址的集合。每一个类都指向了此类的vtable，若子类中被virtual修饰的成员函数，则覆盖父类同名函数，否则继承父类的成员函数。vitual函数的执行是根据对象的VPtr指向的vtable里面的表项来执行的。在赋值过程中，会赋值属性，但是VPtr没有赋值过去。所以会发生以下情况：
```
class Animal{
public:
	virtual void eat(){
		cout << "Animal::eat()" << endl;
	}
}
class Cat:public Animal{
public:
	virtual void eat(){
		cout << "Cat::eat()" << endl;
	}
}
//情况一：a = c
int main(){
	Animal a;
	Cat c;
	a = c; 
	a.eat(); //调用的是Animal的eat()。在初始化时，对象a是根据Animal来初始化的VPtr。赋值操作后，没有讲c的VPtr赋值给a，所以仍然是Animal的VPtr，所以是Animal的eat()
}
//情况二：Animal* a = &c
int main(){
	Cat c;
	Animal* a = &c;
	a->eat(); //调用的是Cat的eat()。传给a的是c的地址，c中的VPtr字段是没有改变的，根据VPtr字段，找到的eat()是在Cat中定义的eat().
}
```
![[Pasted image 20250304220050.png]]
在对象赋值过程中,VPtr指针没有赋值过去。
通过上面的机制实现override。
静态绑定，哪儿个类的对象就调用哪儿个类中定义的函数执行。由上面可以知道，c++在赋值情况下，VPtr的值不跟着变，所以是是静态绑定的。而其他面向对象的语言都是动态绑定的。c++追求效率，所以静态绑定，其他oop语言追求语义，所以动态绑定。
总之，在c++中，单纯的赋值不能实现动态绑定，得通过引用或指针才能向上造型，动态绑定，体现多态性。
- 声明declaration和定义definition与
初始化initialization和赋值assignment
`extern currency p;//declaration`
表达有个全局变量p，不分配内存和空间
`Currency p = bucks;//definition & initialization`
前面由变量的类型，这就是一个定义；在定义变量的时候，给了它一个值，这就是初始化。
  `p = bucks; //assignment`
  已经定义好变量了，你再给他一个值，就是assigment；
 - 在不改变原对象的情况下，要传一个对象进函数，有三段历史。第一个是参数列表中直接传对象，这就涉及了参数列表中对应形参的初始化，以及对其赋值。第二种高效的做法是传递指针，但是可能改变传递进来的对象，这就得加上const。写法上就有很多的星号，所以const引用就不用带星号了。
- 函数作为赋值表达式的左值，在很多情况下是可行的，但是由于没有人掌握它，那句表达式之后，它就失踪了：
```
class A{
public:
	int i;
	A():i(0){}
}
A f(){
	A a;
	return a;
}
int main(){
	A b;
	f() = b; //这句话之后，由于没人掌握f()，它就失踪了。
}
```
- `3` 或`int i = 3;i*3;`，指的就是内存中的某个匿名区域，它的内容是3或者是`i*3` ,类型是`const int` 根据引用的语法，const只能被const引用，所以对函数的形参会有以下情况：
```
//情况一：
void f(int& i){}
int main(){
	f(3); //ERROR,const被非const变量引用了
}
//情况二：
void f(const int& i){}
int main(){
	f(3); //OK，匿名的const被const引用
}
```
- 声明是给编译器看的，用到的地方，只要有声明编译器都能过。但是连接器需要将声明的地方用实际的内容替换。声明是说，有个地方，存储了这样的变量，但是变量在哪儿，不知道，链接器需要知道。定义就是这个地方在这。类中的都是声明。
- 最原始的做法，一个类有一个.h和一个.cpp，分别用于存储声明和body。出现inline function内联函数后，这种局面发生了改变，因为类中的函数，如果把body在声明时候就放在了里面，默认就是inline了，所以可以接受一个类只有.h。后来出现了static修饰的成员变量，因为在类中的static是声明，需要在外面定义后才能用，因此又需要.cpp文件了。
- 任何类的成员函数都有一个hidden parameter叫做this，this是对象的地址。在对类中的static函数进行调用的时候，可以由类名直接访问，没有this。由此观之，static函数的函数体一定没有this。
- 声明的意义：因为编译器是分别对每个文件进行编译的，对于函数或变量由其他文件定义，怎么，而当前文件又需要用，怎么办呢？不可能把定义重新写一遍。正确的做法是，声明存在这个东西，但是在其他文件。下面先用着，编译通过去，到链接的时候，把其他文件的函数或者变量弄过去。这些文件源文件得同时编译才能找到啊。头文件可以不用，预处理会在系统中查找对应头文件的位置。这种认识对定义也有了深刻的认识了。也深化了对extern声明变量，函数声明的意义。
- 编译器对于函数，只是做标记，对函数体的位置的确定，是链接器的事情，因为函数体可能在其他文件中，而编译器一次只能看到一个文件。inline函数就能让编译器把函数的函数体插进去，函数体就能被编译器看到了。
- c/c++中的运算符
	常用：
		算数运算：`+ - * / ++ --`
		位运算：`^ & | ~`
		逻辑运算符：`&& || !`
		关系运算符：`== != <= >=`
	不常用：
		三目运算符：`expression1 ? expression2:express3`
		
