- 为什么`int global` 是一个定义,而`extern int global`就是一个声明？对于变量的定义和声明，怎么使用的？
- 初始化子类的对象，初始化列表中父类的构造函数在初始化列表中靠后，但父类的构造函数会不会更加率先执行？
- cmake为什么在C盘下不能正常运行，项目放在D盘和F盘却正常运行？
- 如何理解返回类型为reference：
```
int x;
int& g(int& x){
	x++;
	return x;
}
```
类比以下，变量`g(int& x)` 完成了赋值操作`int& g(int& x) = x`，这样可以进行两类操作，一是赋值给别人`int k = g(x)` ,而是对引用的变量进行操作`g(x)++` 
函数可以返回引用，但是它们最好引用非本地变量,上面就是对非本地变量的引用。
如:
```
int x = 220;
int* p(){  
    return &x;  
}
```
p()是一个int型的指针变量，完成了`int * p() = &x`的赋值操作
```
int x = 220;
int p(){
	return x;
}
```
p()是一个变量，完成了`int p() = x`的赋值操作

- 为什么拷贝构造copy constructor的声明形式得是`T::T(const T& )` 而不是 `T::T(T )` ?
拷贝构造的时机是出现这种形式的初始化`T t1 = t2`,则运行时会运行等价于`T::T(t2)`的构造函数，实现对变量t1分配内存，对t1每个成员变量按照t2成员变量的模板，分别进行赋值，若是对象，则又将触发拷贝构造。
```
//伪代码是如下：
t1:
int i = t2::i
Object o = t2::o
若是`T::T(T )`,
```
因此，要实现`T t1 = t2`，即实现T(t2):
若拷贝构造的形式是`T::T(T )`,则在对参数列表赋值的时候(`T::T(T parameter = t2)` )，需要T的形参parameter进行构造，出现`T parameter = t2` 形式，则继续递归调用此构造，没有出口。
若拷贝构造的形式是`T::T(const T&)`,则没有产生新对象，不会再调用构造函数，有出口。


- 为什么必须通过指针或引用才能实现动态绑定的功能？
因为类中有virtual函数，所以生成的对象有VPtr指针。VPtr指针指向的vtable是子类的还是父类的,取决于生成此对象时候，是父类定义的还是子类定义的。
在下面的情况一中，函数体生成animal对象是属于类Animal的，VPtr指向Animal的vtable。因此，animal对象访问eat函数，通过vtable给出的地址是类Animal中定义的。
在下面的第二种情况在，在调用f之前，生成了c对象是属于类Cat的，VPtr指向Cat的vtable。在传参数的时候，传递指针，这里的指针animal指向的是Cat的对象，VPtr内容不改变，仍指向Cat的vtable，所以调用f就会调用Cat中定义的eat函数了。
现象如下：
```
#include "iostream"  
using namespace std;  
class Animal{  
public:  
    virtual void eat(){cout << "Animal::eat()" << endl;}  
};  
  
class Cat:public Animal{  
public:  
    virtual void eat(){cout << "Cat::eat()" << endl;}  
};
//情况一：不通过指针，无法动态绑定，输出结果是Animal::eat()
void f(Animal animal){
	animal.eat();
}

int main(){
	Cat c;
	f(c); 
}

//情况二：通过指针，冬天太绑定，输出结果Cat::eat()
void f(Animal* animal){
	animal.eat();
}

int main(){
	Cat c;
	f(&c); 
}
```

- 为什么析构函数要加virtual？
在程序运行过程中，总是有new对象,delete对象，new创建对象返回的是指针，delete也是通过对象的指针来析构。所以涉及了多态中的动态绑定。多态参在upcast，也就是存在Base* 指向Derive对象的情形，在该场景下，若析构不加virtual，即析构函数不在vtable表中，为实函数，则delete调用的是Base中定义的析构函数，而非Derive中的，可能造成资源泄露的弊端。
