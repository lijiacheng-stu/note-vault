#### 头文件的引入
mingw包含了C 和C++的编译器，以及系统自带的头文件，在编译时，编译器就可以根据相对固定的位置找自带的头文件。

#### 变量
- 变量重名，就近原则
- 本地变量
定义在方法中，作用域也在方法中
- 参数
- 成员变量

成员变量是属于对象的，成员方法是属于类的，因为每个不会为每个对象分配内存空间，让它去单独存一份函数的代码，而对成员变量会。
成员变量的作用域包括成员方法和构造器，可以直接使用。在使用成员变量是对象的成员变量，因为有个隐藏的参数this，它是一个指针变量，是关键字，内容是对象的地址。对对象调用函数a.f()时，等价于调用函数`A::f(&a)`
```
class A{
public:
	int i;
	void f();
}
void A::f(){
	i = 20;
	cout << i << endl;
}

//翻译成C语言
void A::f(A *this){ 
	this->i = 20; 
	cout << this->i << endl;
}
```
 


成员方法中涉及的成员变量时会使用对象的成员变量
#### 析构/构造函数

构造函数
要求:
- 函数名与类名相同
- 没有返回类型
特点：
- 在对象被创建后，编译器调用此函数
有参的调用方式：
```
A::A(int initi){
	i = initi;
}
//调用
A a(10);
```

析构函数
要求：
- 函数名和类名相同，tilde(~)前面加
- 不能有参数
- 没有返回类型
特点：
- 在对象被销毁前，编译器调用此函数

初始化列表
- 形式：`constructor():field1(value),field2(value){}`
- 案例：
```
class A{
private:
	int i;
	int j;
public:
	A():i(25),j(2){cout << "inside A::A() << endl"};
}
```
- 细节与本质
初始化列表对属性进行赋值的操作先于构造器，这样的操作叫做初始化。在构造器中对属性进行赋值，叫做赋值，对于对象变量，赋值操作会声明对象时先调用默认构造器，而事实上不一定有默认构造器。
- 初始化列表的意义
意义一：可以让成员变量中是对象的，让此对象不必有默认构造函数 
```
class A{
	private：
		Student s;
	public:
		A(){
			Student s = 0;
		}
}
```
对于上述的函数，s、s1是类student的对象。s先要调用默认构造函数，再让s1赋值给s。这个操作的潜台词是类Student必须得有默认构造函数。
修改成下面：
```
class A{
	private：
		Student s;
	public:
		A():s(0){
			Student s = 0;
		}
}
```
0就是一个Student对象了，直接给属性s这个对象，这Student不需要默认构造器。

当函数的函数体中定义某个类的对象的时候，会先调用default constructor，然后再赋值。

意义二：构造函数后面的初始化列表，需要使用到父类的构造函数
#### 动态内存分配
- new
	- new int
	- new Stash
	- `new int[10]`
- delete
	- delete p;
	- `delete[] p;` 
new用于分配内存，返回值是内存地址。
delete能够释放指针对应的地址。
![[Pasted image 20250301165413.png]]
#### 访问限制
![[Pasted image 20250302154609.png]]
oop原则的破坏：
- 权限的限制仅仅在编译时刻。因为编译结束后的`*.o`文件,和c编译后，汇编语言编译后的程序完全一样，c++失去了其oop特性。
- Friends
![[Pasted image 20250301172735.png]]
![[Pasted image 20250301173216.png]]
声明是朋友的，可以访问其私有变量

类的成员可以被编目，标记为：
- public
任何人都可以访问
- private
只有这个类的成员函数能够访问这些成员变量或者成员函数
注意private是对于类而言的，不是对象而言的。同一个类的不同对象a、b,a的成员函数可以访问b的私有变量

- protected
只有这个类自己，以及它的子子孙孙可以访问这些成员变量或成员函数

#### 函数重载Function overloading
定义：函数同名（must），参数列表不同（must），返回值可同可不同（may）。一定不能函数名相同，参数列表也相同。
默认参数值：
- 定义时从右往左给默认值
- 调用时候，可缺省有默认值的
![[Pasted image 20250302173704.png]]
- 在编译期间起作用，头文件声明时标注后，对应cpp文件不能再标注。再编译期间起作用
- 建议不用
#### 内联函数
- 意义，明确内联函数的优缺点，见机行事地是否使用内联函数
将函数体插入到调用者中，从而减少对地址等的出栈和入栈开销，但是多次调用的情况下，将会增加空间开销，时间开销却大幅减少。
- 如何定义一个内联函数？
内联函数的声明，包括函数体的定义，应该在同一个`*.h`文件中，因为编译器每次只能编译一个`*.cpp`文件，调用函数的地方找不到函数体可不行。
- 使用
和正常函数一样使用，插入操作编译器将自己完成
- 特殊的
若类的声明和函数的定义在同一个文件中完成，则这个函数将会成为一个内联函数，只需要一个`*.h`文件，否则就是一个正常的函数，一个h文件声明类，一个cpp文件定义类的成员函数
#### 软件重用的方式
一、组合
对象或者指向对象的指针作为属性的一部分。用对象拼出一个新的对象
二、继承
1.基本概念
1.1概念：
继承：通过对已有的类进行改造，生成新的类
已有类：基类/父类/超类
新类：派生类/子类/副类
![[Pasted image 20250302153032.png]]
2.范围
从成员变量和成员函数的角度来讲，派生类是基类的超集；
从范围来讲，基类大于派生类。
2.父类与子类的关系
2.1可见性
涉及private protected public的访问限制
![[Pasted image 20250302154609.png]]
2.2函数重载
函数重载：函数名相同，参数列表不同。
再同一个类中，根据参数列表的不通过，根据调用时的不同参数列表。
对于父子类之间，子类若存在同名函数，父子类的函数将没有任何关系，父类中的所有此名字的函数将会隐藏，只有通过解析符号，才能够显示调用出来。
2.3构造和析构函数
前提：在主函数中声明了子类的对象
调用次序：父类构造>子类构造>子类析构>父类析构
特殊：
- 若父类是默认构造，则子类中不需要在构造器中声明对父类的构造
- 若父类不是默认构造，则必须在初始化列表中声明对父类的构造



#### const
1.指针和const
1.1.考虑指针是const还是指针指向的内存是const
![[Pasted image 20250303222951.png]]
可能指针是const，而指针指向的变量不是const：
```
int a = 10;
int * const p = &a; //指针是const
*p = 11 //ok
p++ //error
```
可能指针不是const，指针指向的变量是const：
```
int a = 10;
int const *p = &a; //*p是const,与const int *p等价
p++; //OK
(*p) = 20; //ERROR
```
1.2.考虑const变量对含可能含有const的指针的赋值
原则：不能出现自相矛盾
```
const int a = 10;
int *p = &a; //ERROR，*p可以变，但是a不能变，p指向a，矛盾
int cont *p = &a; //OK
int * const p = &a; //ERROR，p不能变，但*p可变，a不能变，p指向a，矛盾
```
2.const与对象
对象被const标记，则对象的属性不可被修改，对象的this也不可被修改。所以有这样的推论，对象调用的函数不能修改属性值。则，成员函数中，被const标记，则函数体中的内容不能修改属性值。对象只能调用被const修饰的成员函数。const对象的本质是`const B * const this` 也就是this是const， `*this`也是const


#### 引用reference
掌握一个数据的三种访问形式
```
char c; //a character
char* p = &c; //a pointer to a character
char& r = c; //a reference to a character
```
第三种的reference就是引用，或者叫做别名alias。r和c都代表同一个地址区域了，可以完全等同使用。
![[Pasted image 20250304155529.png]]
上面提到引用在定义时必须初始化。但是有两种情况，它们也是需要初始化，但是初始化的时机不是在刚定义的地方：
变量在参数表（初始化的时机是调用函数），成员变量（初始化的时机是调用函数）不需要对引用进行初始化，否则本地变量和全局变量需要初始化。
![[Pasted image 20250304160043.png]]
上面提到不能改变绑定，因为`int& s = p;`表示s是p的别名（引用），若要改变两种可选的方法`int& s = j;` 这不行，因为重复定义；`s = j;`这也不行，因为这句话表示j的值赋值给s，而不是改变绑定关系。
绑定必须有个地址，说明不能是具体的数字进行赋值，应该是一个有变量名的参数。
![[Pasted image 20250304160939.png]]
多态 polymorphism
![[Pasted image 20250304174340.png]]
向上造型upcasting
将子类看成父类的行为：学生还是学生，我们把他当人看了；橘子还是橘子，我们把它当水果看了。
动态绑定 dynamic binding
只有通过指针去访问对应的函数，才是动态绑定。 通过点去调用不会是动态绑定。
绑定：子类和父类都有相同函数名的函数，哪儿个函数被调用？
![[Pasted image 20250304175433.png]]
其他oop语言默认动态绑定，只有c++默认是静态绑定。
什么是静态绑定？什么是动态绑定？


static
static有两个功能，一个是hidden，一个是persistent。hidden，体现的是一种对访问属性的限制。如static修饰本地变量，就这能被这个static的func中访问。作为全局变量，就只能被这个文件访问，另一个文件就访问不到。但是类的中的static这个hidden功能被private，protected和public取代，更多的是persistent的功能。在本地变量中，static修饰后，存放在全局数据区中的一个内存区域，只初始化一次，到运行结束才收回内存空间。全局变量的static的性质也是如此。在类中，static修饰成员变量，则表示这个变量由所有对象共享，也可以直接类名访问，需要注意的是，类中是声明，用到的地方需要定义。static修饰成员函数，所有的对象都共享这个函数，但其中共享式没有意义的，本来就是共享的，多出的功能是能够用类名访问函数了，但是由于可以不由对象调用，所以成员函数中的hidden parameter this就不能用。
static修饰的本地变量，存放在全局变量区的一个固定位置，与其他全局变量相比有一个特殊的访问属性，只有函数的内部能够被访问。第一次调用函数时初始化，且只初始化一次。全局数据区，在编译的时候就为变量分配好了内存空间。全局变量区中的变量在运行结束的时候释放内存，调用析构。
static修饰的全局变量，只能在当前文件被访问。
static修饰成员变量。所有的对象共享此成员变量，且需要定义，可以用类名访问。
![[Pasted image 20250305173721.png]]

运算符重载
