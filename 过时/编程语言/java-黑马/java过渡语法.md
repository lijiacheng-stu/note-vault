### 方法
#### 概念
![[Pasted image 20240314153430.png]]
#### 方法的定义与调用
##### 3种
**简单方法和调用** 
![[Pasted image 20240314153621.png]]
![[Pasted image 20240314153751.png]]
**带参数的方法和调用** 
![[Pasted image 20240314154518.png]]
![[Pasted image 20240314154537.png]]
**带返回值的方法和调用** 
![[Pasted image 20240314155242.png]]
![[Pasted image 20240314155313.png]]

##### 注意事项
- 方法是没有先后顺序的，可以在main方法的任意先后位置
- 方法得不能定义方法
- 方法被main调用后才执行
![[Pasted image 20240314155853.png]]
![[Pasted image 20240314155916.png]]

#### 方法的重载
**概念**
![[Pasted image 20240314160734.png]]
关键：同一个类，同一个方法名，不同的参数列表（个数不同，类型不同，顺序不同）

#### 方法的基本内存原理
可以用stm32种用到的中断机制进行理解，需要说明的是，方法是执行时在栈里的。每个方法都有自己的命名空间，不同方法之间名字相同的变量，也不会互相串扰
基本数据类型，在栈里面，变量存储的真实的数据，赋值将会是真实值（整形，浮点型，字符型，布尔型）
引用数据类型，在站里面，存储的是地址值，真实值在堆里面，赋值将是赋值地址


### 面向对象
#### 概念
**面向对象**
![[Pasted image 20240314164421.png]]
**类和对象的关系**
手机：iPhone
老师：欧阳老师
![[Pasted image 20240314164853.png]]


javabean类和测试类
![[Pasted image 20240314170829.png]]
![[Pasted image 20240314170936.png]]

### 封装
#### 概念
**三大特征**之一：如何正确设计对象的属性和方法：
- 写什么属性和方法
- 对于涉及多对象的需求，如何将方法合理地分配给正确地类
- 如何正确地修饰权限修饰符
**原则**：对象代表什么，就得封装对应的数据，并提供数据对应的行为
#### 权限修饰符号
private

![[Pasted image 20240314173638.png]]
#### this的使用
**成员变量**：作为类的属性的变量
**局部变量**：在方法中定义的变量
**就近原则**：当方法的局部变量和成员变量重名时，比如成员变量有name，方法中也有name，谁距离方法就用谁，则优先使用方法中的name，若方法中没有局部变量，则使用的是成员变量的name
**需求**：当方法的局部变量和成员变量重名时，如何才能让方法使用成员变量呢？this.name
**内存角度理解** ：this代表的是对象所在堆的地址值，也就栈中的方法通过this找到对应的堆中的变量，也就是成员变量了。 而没有this的，那就是栈变量啊，也就是局部变量了。
![[Pasted image 20240314183501.png]]


#### 构造方法
![[Pasted image 20240314174856.png]]
![[Pasted image 20240314175005.png]]

![[Pasted image 20240314175401.png]]
![[Pasted image 20240314175458.png]]



API


### 字符串
#### String
![[Pasted image 20240315140928.png]]
![[Pasted image 20240315141319.png]]
##### 创建字符串
![[Pasted image 20240315143042.png]]

**new和直接赋值的区别：**
1、串池（字符串常量池）是在堆里面的区域
2、new出来的字符串，并不在串池里
3、当两个变量所指的字符串相同时，对于直接赋值的，那么将都在串池中，两个变量指向同一个，节省内存；对于new的，则会创建两个，浪费内存。
![[Pasted image 20240315143608.png]]
##### 字符串的方法
###### 字符串的比较
![[Pasted image 20240315144118.png]]
![[Pasted image 20240315151918.png]]
##### 遍历字符串
![[Pasted image 20240315152006.png]]
tips：要判断一个字符是否是大写字母，if('A'<=chr<='Z')
##### 拼接字符串
String+其他类型 
str.concat()
#### StringBuilder
![[Pasted image 20240315161128.png]]
**常用的方法**
![[Pasted image 20240315161206.png]]
![[Pasted image 20240315161223.png]]
**链式编程**
![[Pasted image 20240315161621.png]]
**用途**
字符串拼接
字符串反转

#### 字符串相关类的底层原理

![[Pasted image 20240315163756.png]]
##### 原理1和2
![[Pasted image 20240315163839.png]]
##### 原理3
**情况1：没有变量参与**
![[Pasted image 20240315164018.png]]
**情况2：有变量参与** 
![[Pasted image 20240315164932.png]]
- JDK8 之前
s2=new StringBuild().append(s1).append("b").toString
![[Pasted image 20240315170124.png]]
分析：在JDK8之前，拼接n个变量，会产生2n-2个对象（new StringBuilder和toString都会产生新对象，且都是不再串池中）

- JDK8之后
//先对要加的式，有几个就创建一个数组，然后再把字符串数组转成字符串
String[] str={s1,"b"};
s2=str-->字符串
分析：在JDK8之后，拼接n个变量，会产生2个对象

- 总之
![[Pasted image 20240315171717.png]]

##### 原理4
![[Pasted image 20240315173015.png]]

##### 原理5
![[Pasted image 20240315172935.png]]

### 集合ArryList
#### 概念
长度：自动扩容
存储类型：集合不能直接存储基本数据类型
泛型：限定集合中存储数据的类型

#### 常用方法
增
list.add(E element)
删
list.remove(int index)
改
list.set(int index,E element)
查
get(int index)