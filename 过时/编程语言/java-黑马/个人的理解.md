#### 运行规则的理解：
**对于一个文件的运行**
类文件包含了很多类
类 包含了很多种的属性和方法
一个类文件的运行，只运行这么多类方法中的与文件名相同的那个类，在这个类中又只运行main这个方法

对于跨文件，甚至是跨文件夹呢？

#### 对于数组内存图的理解
- 对于引用数据类型，数据的真实值将存在堆中，地址值存在栈中的变量内中。
- 运行中的方法是存储在main的，main是第一个进最后一个出，当然存储在栈中。
- 引用数据类型的变量是可以赋值的，这里的赋值将会是地址的赋值，那么必然将导致两个变量同指向同一片地址空间，那么通过一个变量改变此数据，另一个变量也会改变。


#### 一个需求，涉及多个对象，如何设计对象的属性和方法？

#### 对于数组的arr.length 和对于String的str.length()的区别？
无论是数组还是Sting其实地位是一样的都是类，但是length对于数组来讲是它的一个属性，length()对于String来讲是一个方法

#### 对于ArrayList、String、StringBuilder、基本数据类型、其他类的引用数据类型的变量在打印时的差别？
String,StringBuilder显然是两个特殊的类，它们和基本数据类型一样，打印的时候打印的是不地址而是内容，而其他数据类型则是地址，如下：
```java
//input
int number=8;//基本数据类型
Sting str="abc"; 
StringBuilder sb=new StringBuilder();
Phone ph=new Phone();
Array

//output
sout(number);//8
sout(str);//abc
sout(sb);//abc
sout(ph);//edu.hebut.stu.Phone@10f87f48
```
#### 在java底层存储原理中，如果说new出来的对象，没有变量指向它，会怎么处理？
如：new StringBuilder()，StringBuilder的垃圾对象
```java
String str1="abc";  
String str2=new StringBuilder().append(str1).append("b").toString();
```
csdn：
在Java底层存储原理中，如果new出来的对象没有变量指向它，会通过垃圾回收机制进行处理。Java中使用的垃圾回收器会定期扫描堆内存，找出那些没有被任何变量引用的对象，并将其标记为可回收的垃圾对象。当系统需要释放内存时，垃圾回收器会收这些垃圾对象所占用的存空间。
具体的垃圾回收算法有很多种，其中最常见的是标记-清除算法。算法通过标记所有活动对象，然后清除未被标记的对象来回收内存。当没有变量指向一个对象时，该对象就会被标记为回收的，等待下一次垃圾回收时被清除。
需要注意是，垃圾回收的具体时机是由Java虚拟机自动决的，开发者无法精确控制。但可以通过调用System.gc()方法来建议虚拟机进行垃圾回收，但并不保证立即执行。



#### java中的内存机制是怎么运行的，如何描述方法区、堆、栈之间的协调机制？
答：
- 先介绍概念
**方法区**：运行的main所涉及的存储class字节码文件，且随着main文件的运行而加载（什么时候退出呢？）（主要作用其实是寄存方法的）
**堆** ：存储引用类型的变量 （主要作用是寄存属性值和指向方法的地址）
**栈** ：存储正在运行的方法，是栈的结构 （主要作用是存放正在执行的方法）
**一般存储方式** （自编）：在栈区中形成”变量=实际值的地址“，在堆中对应的地址处存储相应的数据。这里的数据包括属性的数据，已经字节码对应的地址数据（用于找到字节码，并寻找方法）
**一般打印方式**（自编） ：（`sout（变量名）` 打印出的是地址值）
**真实数据（值）** （自编）：对于属性，存储数据本身；对于方法，存储地址，这个地址指向方法区的字节码文件。
- 运行机制
首先main所在的字节码文件加载到方法区，对应的main方法加载到栈中，程序从main的第一条语句开始执行。
当执行的语句涉及变量时候：
- 基本数据类型：直接存储在栈区中，形成"变量=实际值“的”连接“
- 引用数据类型：
	- 非类： 
		- 数组：一般存储方式，一般打印方式
	- 类： 
		- 步骤一：
			所涉及的类的字节码文件进入方法区，同时对于static修饰的变量将会存储于堆中的静态存储区中，这个位置是这个类的所有对象所共享的，产生于对象产生之前，也可以在对象产生之前进行赋值（推荐）。
			步骤二：
			- String：
				- 若为`String str1="abc";`  在栈区中形成”变量=实际值的地址“。在堆中的串池中的相应地址位置存储字符串"abc"，当另一个字符串变量`String str2="abc"`时候，str1和str2所指向的地址是一样的，都在串池当中。
				- 若为`String str1=new String("abc")` 在栈区中形成”变量=实际值的地址“,在堆中一般区域相应的存储位置存储相应的字符串。当另一个字符串变量`String str2=new String("abc")`时候,str2将与新的地址产生连接。
				- sout(str) 打印的不是地址，而是地址值对应堆中存储的实际值。
			- ArrayList: 一般存储方式，`sout(list)` 打印的是ArrayList内容`[adf, edgfsa, hello]`
			- StringBuilder:一般存储方式，`sout(sb)` 打印的是StringBuilder的内容`helloword`
			- 普通类：一般存储方式，一般打印方式。
- 当执行的语句涉及方法时：
	在堆中寻找调用方法的对象的真实值，从而找到方法的地址，根据地址，将方法区中对应的方法加载到栈中，开始执行。
	每个方法的命名空间是相对独立的，每个变量可以说是局部变量吧。
	调用这个方法的方法的所指向的对象和这个方法的所指向的对象是同一个。所以在调用方法时，对对象的属性值进行修改，将对反馈到调用这个方法的方法中。

补充：
- 当涉及到的类存在继承关系的时候 如
```java
class Fu{
	private string name;
	int age
	private void eat(){
		sout("I am eating");
	}
	public void work(){
		sout("I am working")
	}
}
class Zi extends Fu{
	String game;
}

public class Test{
	psvm{
		Zi z=new Zi();
		z.age=18;
		z.name="Die";
		z.work();
	}
}
```
执行`Zi z=new Zi();`时：
步骤一：
Test类进入方法区，main方法入栈
步骤二：
Zi类进入方法区，Zi类的父类Fu进入方法区，形成Zi指向Fu的指针
步骤三：
栈中形成`z=地址` 的连接
步骤四：
堆中对应的地址形成一个框，这个框从左到右分割成多个区域，分别存储Zi，Fu的成员变量的属性信息，也存储这对象指向对象所属的类的字节码的地址信息。
步骤五：
`z.age=18;` 对于变量的访问，在不作特别说明时候，会从框从左到右进行访问，发现age后，检测age前的修饰词，非private访问，完成赋值；`z.name="Die";` 属于private不能被赋值。
步骤六：执行`z.work()`
直接参照进阶语法对于extends中的介绍就行




#### javabean类、测试类、工具类、适配器类有什么区别和联系？
**javabean类**用于描述一个事物，比如学生，猫，老虎。包含描述这些事物的属性和方法。javabean作为一个标准的类，也有一些规范：所有的属性都得private；给每个属性提供get和set方法；构造方法有无参构造和全参构造两种。 
**测试类**：只包含psvm，用于书写类进行测试。
**工具类**：给JavaBean类提供一些静态方法。本身不需要产生对象，所以其构造方法用static进行修饰。其他的方法都得通过static进行修饰。
**适配器类** ：当接口Inter有很多抽象方法，但是jevabean类只需要用到其中一部分的时候，javabean类实现接口，那么就会空重写很多方法。为了解决这个问题，可以创建InterAdapter类实现Inter，对方法空重写，然后Javabean类继承InterAdapter，最后在实现自己需要的那几个方法。由于InterAdapter是不需要创建对象的，所以直接abstract修饰就行。
总之，工具类和测试类都是为JavaBean类服务的，工具类为JavaBean类提供静态方法，测试类额对JavaBean类进行测试。



#### 方法的嵌套的情况下，权限的管理是怎样的？
背景：上面的讨论都是基于在main方法中，通过创建对象，对利用对象调用方法与成员变量的讨论。但是对于调用的方法，存在方法的嵌套是没有讨论到的，是不是都是适用于main方法的情况呢？




#### 方法的重写和重载有什么区别呢?


#### 多态中”编译看左边、运行看（左边，对变量）（右边，对方法）”的调用特点，对当前类对属性和方法的调用有什么影响吗？
答：

#### `Fu f=new Zi();`父类和子类是怎么存储的？
在堆中，




在代码执行过程中，方法和成员又是如何调配的？


#### 如何理解字符串不能改变
String数据内容是 `private final byte[] value;`  



#### 封装、继承、多态、抽象类（抽象方法）、接口的推导过程是什么？
数据很多，针对数据的行为也很多，这就会非常凌乱。所以得将零散的数据和行为封装成一个整体，怎么封装呢？对象代表什么，就得封装对应的数据，并提供数据对应的行为。这就形成了对象或类。这就是封装了。
当这种对象越来越多的时候，问题就出现了。有很多的类具有重复的内容，形成了大量的重复代码。为了解决这个问题，将同一个事物中的共性内容抽取到一个类中，这个类成为父类，被抽取的类称为子类，在这个结构中，子类能够直接访问父类中非私有的内容。由于子类中不需要再写被抽取的内容，从而提高了代码的复用性。这就是继承。
被提取的共性内容，如“工作”这一方法，对于不同的子类其内容是不一样的，对于老师内容是教书，对于校长，工作是行政管理，父类不能对这一方法进行统一。是不是认为“工作”不是共性的方法，然后让每个子类自己书写工作的方法呢？如果是，那么实际操作中会出现对工作方法命名不统一的问题，这让方法的调用变得非常复杂。所以得保证将这一方法需要提取在父类。再这种的情况下，提出了这样一种方案，在父类中对这一方法进行书写，作为一种通用的方法内容，同时为子类提供重写的权力； 但是在必须子类需要重写的情况下，父类不需要再对方法体进行书写，但是子类自己重写的情况下，语法并不会报错。为了满足这个需求，就产生了抽象类和抽象方法。在这种方法下，子类必须重写对应的方法才不会报错。
在继承中，把所有子类中的共性方法和属性提取在一起形成了父类，但是也存在这种情况，有一些方法，它虽然不适合于所有的类，但是子类中很大比例具备这个方法，比如，动物，不是所有的动物都会游泳，但是有相当一部分的动物是会游泳的，如果对游泳的方法放任不管的话，这一方法将会有很多种写法，这又会导致调用很困难。 同时，有一些方法（游泳），并不是只有动物这个大类才有，植物也可能会有。 因此需要一个方法来规范游泳这一方法。将一组这个的方法集合在一起，这就产生了接口。接口不仅同一命名规则，还进一步扩充了参数列表。传入的参数不再只是指定的类或者指定的数据类型，还出现了接口，只要有这个接口的类都能传进来。比如，计算搬家所需要的时间的方法，车能搬家， 搬家公司也能搬家，只要能搬家就行，但是搬家公司和车却没有相同的父类。由于接口是一类函数名的集合，那么在类实现接口后，说明这个类必须实现接口类的所有的函数。现在，在设计之初，这是完全没问题的，但是随着需求的增加，接口中需要增加新的方法，而已经实现这个接口的类却不一定用得上新增的方法，但是如果没用上，又会报错。这怎么办呢？于是出现了`public default void method(){}` ，类如果用上了，就重写`public void method(){}`,
没用上也不会报错，可以调用。这样对升级的接口就不会影响到原来已经实现的类了。

#### 为什么要有包装类呢?
如果没有包装类：
- public void method(object obj){} 如果参数传的是数字且没有包装类，那么将会报错
	- 除了8种基本数据类型外byte short int long float double char boolean 其他的数据都是对象 
- 集合中只能存储对象，不能存储基本数据类型
#### 为什么说interface中的变量，默认使final static修饰，即 `int a=15;`其实是`final static int a = 15`?
代码的形式说明：
```java
//接口Inter中定义了变量int a=15;
public static void main(String[] args) {  
    System.out.println(Inter.a); //接口名.变量名 的访问方式说明a使static修饰  
    Inter.a=16; //报错，原因是不能对final变量赋值  
}
```
使用内存分析工具HSDB
步骤一：运行测试类，保证此过程程序不停止，通过Scanner
步骤二：jps命令，查看测试类的程序编号
步骤三：jhsdb hsdb命令，进入到hotspot debugger
步骤四：点击左上叫，与程序编号进行连接
步骤五：打开字节码文件，查看类，查看方法，成员变量


#### 私有方法的作用？为什么静态方法不能调用动态方法？
这个方法由于被private修饰，那么就不能被其他的类调用，它的作用是抽取本类中其他方法的重复代码，为本类中其他方法进行服务，提高代码的复用性。
私有静态方法又有什么用呢?要知道，动态方法得在实现类的对象下才能够被使用，而静态方法是在接口的字节码被导入之后就可以使用。静态方法调用动态方法，那么静态方法在实现类没有创建前就没法使用了，所以不行。但是私有静态方法却解决了这个问题。
这也解释了静态函数的封装不能调用动态方法。


#### 为什么一般命名的时候不用_下划线和$符号？
_ 下划线一般用于常量的命名；$ 一般表示内部类。
在上面的习惯下，如果贸然命名，则会产生误会。



#### 对this的理解是什么？
this的级别是一个对象，这个对象的地址是调用者的地址值


#### 对象.addActionListener(ActionListener l)的理解
对这个函数来讲，传入ActionListener实现类的对象，调用这个对象中
```
public void actionPerformed(ActionEvent e) {  
}
```
触发事件这个事件的类，是执行事件的类时两个类，e就是触发这个事件的对象吗?
`object o=e.getSource()` 就可以得到o所指向的地址跟触发事件的地址时一样的。
问题：调用者对象的地址为什么会赋值到e中呢？

#### 构造代码块和静态代码块的区别



#### 接口怎么创建对象呢？
接口不能创建对象， 要创建对象只能通过其实现类。但是可以通过多态来实现。
```java
Collection<String> coll=new ArrayList<>(); 
```
-->接口怎么创建另一个接口的对象呢？
例如：Collection的对象创建Iterator的对象，已知Collection和Iterator都是接口
```java
Collection<String> coll=new ArrayList<>{};
Iterator it=coll.iterator();
it.hasNext();
it.next();
```
原理：ArrayList是Collection的实现类，Collection中有iterator()方法，实现类中重写了这个方法。iterator是一个接口，里面有hasNext()和next()方法。所以iterator()的函数返回值是iterator的实现类，具体在源码中，就是ArrayList中的内部类。

#### 在调用重载的方法时，方法中填写的参数同时符合两个方法的情形有哪儿写？在这些情形下调用的是哪儿种方法？本质的是什么？
本质：优先调用实参类型与形参类型一致的方法
情形：
- 形参是父子类，构成多态
```java
//声明
class A{
	method(ClassSon b);
	method(ClassFather b);//ClassSon extends ClassFather
}
//调用
ClassSon b;
A a;
a.method(b); //调用第一个
```
- 形参是Object，包装类，基本数据类型 //存在父子类构成多态，自动装箱，自动拆箱等机制



#### forEach()方法与lamda表达式的使用讨论？
- 这个方法的范围
**继承关系：** 方法在接口Iterable中被定义，接口Interator继承了Iterable，接口Collection继承了Iterator
**结论：** Collection的实现类都可以有foreach方法
- `default void default void forEach(Consumer<? super T> action)`
**形：** 点击Consummer,发现是函数型接口，可以使用lambda表达式
**神：** 
- forEach方法的填写的是Consumer接口实现类的对象。
获得实现类对象的方法是匿名内部类或者lambda表达式，重写接口中的方法。
- forEach方法的函数体对于我们来讲仍然是透明的。我们不知道它是如何使用我们所传入的对象的，也不知道它是如何调用我们上面重写的方法的。
- 这相当于是将forEach中的部分代码交给我们自己写。
```java
//书写接口
interface ItTest<T>{
	void accept(T t);
}
//书写调用类
class Mcall<T>{
	T t;
	public void method(ItTest<? super T> action){
		action.accept(t);
	}
}
//测试类
class Test{
	//当Mcall中的泛型填了String后，对象m的属性t的数据类型就是String，ItTest<? super String>,那么accept能够接收的对象也是<? super String>，就能够多态接收了。
	Mcall<String> m=new Mcall<>();
	m.t="hello";
	//当创建ItTest的匿名内部类对象后面的泛型确定为String后,accept接收的也就是String了
	//本质调用的还是method中的方法体，方法体对于我们使用者来讲仍然是透明的，它怎么调用我们使用的方法，对我们来讲是未知的。
	m.method(new ItTest<String> {
			accept(String t){
			sout(t)
		}
	}); //hello
}
```





#### java中如何实现链表
![[Pasted image 20240329203830.png]]



#### 类（中的方法）与类（调用后的表现形式改变）之间的关联？如toString与sout，hashCode eaquals与HashSet，Comparable，Comparator与TreeMap
##### 对于Comparator的匿名内部类中的重写方法和应用场景的理解，以及其与Comparable之间的关系？跟TreeMap和TreeSet有关
###### 对Comparator重写方法的理解，以及对于TreeSet和TreeMap的作用
```java
TreeMap<Integer,String> tmap=new TreeMap<>(new Comparator<Integer>() {  
    @Override  
    public int compare(Integer o1, Integer o2) {  
        return o1-o2;  
    }  
});
```
已知：
- o1 新的数据，o2老数据
- 返回值int，正数表示新数据插在后面， 负数表示新数据插在前面，为0时，HashSet不操作，HashMap进行覆盖。
讨论：
- 当`return o1-o2` 时，当o1小于o2时，o1-o2是负数,o1放在前面，当o1大于o2时,o1-o2是正数，o1放在后面。 所以小的放在前面，升序排列。
- 当`return o2-o1;`  时,当o1小于o2时，o2-o1是正数，o1放在放在后面，当o1大于o2时，o2-o1是负数，o1放在前面。 所以小的放在前面，降序排列。
方法：
- 令`o1<o2` ，判断式子的正负（式子的正负，决定新数据的位置），负为o1插在o2前面，升序，反之降序。
###### Comparator的应用场景，以及其与comparable之间的关系和区别
###### 使用场景
- 通俗：comparator和comparable就是为TreeSet和TreeMap量身定做地。
- 通用：对于Compatator,constructor的参数如下时候可用,在构造器中写匿名内部类：
![[Pasted image 20240331095857.png]]
![[Pasted image 20240331100014.png]]
###### 区别：
**Comparator**
- Comparator以匿名内部类的形式写在构造器中
- 不受Comparable的影响，是对排序规则的补充，拥有很高的优先级
**Comparable** 
- Comparable写在泛型确定的实现类中
- 受Comparator影响，是排序的默认方法，拥有较低的优先级。
###### 联系
一个类如果是Comparable的实现类，那么它在TreeMap和TreeSet中的排序规则就确定了。当这一排序规则不能满足时候，就需要用到Comparator了。
已知道的Comparable的实现类，以及其排序规则有：
- String:一个一个字符地按照ASCIII表比较，更小排在前，相等比价下一个
- Iteger,Double:升序排序.

##### toString方法与System.Out.println()之间是什么关系？
已知
- toString方法是Object中的方法，所以所有的类都有。
- System.Out.println()有重载现象，其中就有System.Out.println(Object x)
![[Pasted image 20240331104633.png]]

- String.valueOf(object x) 底层调用了toString方法
结论：**System.Out.println(Object x)打印对象时候，打印的就是x.toString** 

##### hashCode方法和equals方法与HashSet之间的关系？跟HashSet和HashMap有关
已知：
- hashCode方法，是Object中的方法，默认将对象的地址值转成一个整数，也可以根据属性转，这样的话属性值相等的两个对象，调用hashCode方法会得到相同的数值
- HashSet对加入的对象，逐个地放入Hash表中。放入规则如下：
	- Hash表由数组和链表组成，每个数组的元素是一个链表的表头,记为0~15链表，数组长度是16
	- 调用对象的hashCode方法，通过以下，准备将其放入对于链表中。
	![[Pasted image 20240331111000.png]]
	- 一致HashSet是不能存相同的数据的，而相同的数据会计算在相同的链表上，所以需要对比这个链表上的每一个数据，相等则（不操作HashSet/覆盖HashMap），不相等加入，挂在链表最后面。相等的评判标准就是调用equals方法，默认是比较地址值，也可以重写为属性值
	 - 默认加载因子为0.75，所以16*0.75=12时，数组翻倍，16->32
	 - 当链表长度大于8而且数组长度大于等于64时候，链表将转成红黑树

#### Throwable，Exception，RuntimeException与IndexOutOfBoundsException等子类之间的区别与联系？
**现象：**
- Trowable中，
三个常用的方法：toString(),getMessage(),printStackTrace(),
两大构造方法：Throwable(),Throwable(String)
媒介变量：detailMessage
 作用机理：当使用Throwable(String)时，str赋值给detailMessage，Throwable()时，str就是null，toString()返回类名+str,getMessage()返回str
- Exception RuntimeException中，构造器直接调用的是Trowable的Throwable(),Throwable(String)，没有增加其他方法
- IndexOutOfBoundsException，新增了一个构造器，但是其函数体仍然是调用了Throwable中的方法。
**结论**
各种异常，本质上只是名字不同，用于区分不同的异常。
当函数没有设置抛出异常的机制的时候，那么虚拟机会抛出异常，这时候虚拟机会使用各种子类异常中特有的方法来使用，然后终止程序运行。
我们自定义的异常，也就只能从那两个构造器入手，影响detaiMessage，继而使调用的方法有区别。


